# 创建变量

- `a=1`
- `var a = 1`
- `let a = 1`
- `const a = 1`



## **j s的发展过程就是一个血淋淋的打脸过程!**

```javascript
'首先要清楚 a = 1 和 var a = 1 的区别'

第一个要明白一个机制:
	先声明,后赋值!!!
所以,既然要先声明,后使用,那么var 就直接在所在的作用域里
变量提升得了! 
我们也不要一口气,把想要使用的都声明完,再使用,也算是一个语法糖吧!

var a = 1   相当于
{
    var a  //声明
    a = 1  //赋值
}

这就说明了`a=1` 这个语句没有声明,直接就赋值了,就本身应该是错误的!!!!
但是js 为了'作秀'--->自己很好用!  就默认给这个语句加了一个`var a`  算是语法糖吧! 
造成了 全局命名空间混乱的问题!
    

```



## **这个语法糖到底是什么?**

```javascript
function xx(){
    a = 1
  console.log(a)
}
xx()

`分析上述代码`
xx函数执行时,需要用到a,先去找a的声明,在函数作用域去找,没有找到!!
就去外面的作用域找(这里其实就是全局作用域),发现也没有!!!
那不行啊,全局作用域就是最大的作用域,别无他处可寻!
但是,又必须要用,怎么办呢?
那算了,你不是自己没有声明吗!那么我直接帮你在外面给你声明一下,你程序员大爷直接用,那不就得了!
反正,都是一群懒鬼,穷屌丝!
```



## **`var`用的好好的,为什么要搞一个 `let`?** 



### `var`的问题!

```javascript
由于上述两个 var的　语法糖，造成一个污染全局命名空间的问题！
就和生活中一样！方便带方便了人类，却污染了环境！

究竟是如何污染的呢？
function xx(){
   var a = 1
  console.log(a)
}
xx()
`再次分析这个代码：`
我们的本意,其实是想在 打印a,但是又不想把 a 暴露给全局, 因为可能有'重名',可能被人'乱改'!
所以,我们用函数作用域 , 也就是xx函数,包裹,这样有两个好处:
 1.我什么时候想用,就什么时候用
 2.a作为函数的属性,不会直接暴露给全局


`但是:`
 这个问题还是没有得到彻底解决------>因为我们还是在全局里面暴露了一个属性 ---> 函数xx!
     

`进一步:`
 如何解决函数暴露在全局的问题呢?
 
 '函数自调用!'
格式:
(
 function (){
    逻辑; 
     
 }()
 )

我们写一个匿名函数,换句话说:'没有xx了'  自然也就不会暴露什么了
这个函数自己执行[后面跟了一个括号!]
最后在最外面套一层 (),解决语法报错问题!

```



### `let`是如何解决的呢?

```javascript
let 的语法:
{
    let a = 1
}
定义了一个a ,这个a,只在 花括号里面起作用!
 
这样,就彻底解决了,变量暴露在全局的问题!!!
```





## `const`定义字面量常量!

> 只可以定义一次
>
> 只可以在定义时被赋值
>
> 之后不可以更改了!

**定义变量最长用的就是const** 

- 让同事不要随意改
- 注意点
  - 初始化的机会只有一次
  - 定义一个对象, 这个对象不可以改,但是可以修改里面的属性
  - 内存角度:
    - 变量指向的内存地址不可以改
    - 但是内存里面的数据可以改动





# 深挖let

阅读`mdn`后：

- let 声明的变量的作用域是块级的；
- let 不能重复声明已存在的变量；
- let 有暂时死区，不会被提升。 （这是有问题的）
  - 暂时死区就是指的是变量在初始化之前不可以使用变量

问题1：

​	为什么let  i 可以 解决绑定问题？

```javascript
var liList = document.querySelectorAll('li') // 共5个li
for( let i=0; i<liList.length; i++){
  liList[i].onclick = function(){
    console.log(i)
  }
}
```

**然而，用我之前的知识来理解这个代码是不能自圆其说的**。

因为代码中依然只声明了一个 i，在 for 循环结束后，i 的值还是会变成 5 才对。



这证明了我对MDN的认识有有问题!

新的理解:

1. **for( let i = 0; i< 5; i++) 这句话的圆括号之间，有一个隐藏的作用域**
2. **for( let i = 0; i< 5; i++) { 循环体 } 在每次执行循环体之前，JS 引擎会把 i 在循环体的上下文中重新声明及初始化一次。**

```javascript
var liList = document.querySelectorAll('li') // 共5个li
for( let i=0; i<liList.length; i++){
  let i = 隐藏作用域中的i // 看这里看这里看这里
  liList[i].onclick = function(){
    console.log(i)
  }
}
```



**这个现象背后是为什么呢?**

- 要搞清楚提升的本质!
  - 需要理解 JS 变量的「创建create、初始化initialize 和赋值assign」
  -   创建-->初始化–->赋值
- var 
  - 会在代码执行之前就将「创建变量，并将其初始化为 undefined」。
- function
  - 会在代码执行之前就「创建、初始化并赋值」。
- let
  - 找到所有用 let 声明的变量，在环境中「创建」这些变量
  - 开始执行代码（注意现在还没有初始化）
  - 执行 x = 1，将 x 「初始化」为 1（这并不是一次赋值，如果代码是 let x，就将 x 初始化为 undefined）
  - 执行 x = 2，对 x 进行「赋值
- let 先创建变量   等`js`执行代码，然后初始化 let x = 1 这是初始化   x=2 最后赋值 

**看到这里，你应该明白了 let 到底有没有提升：**

1. let 的「创建」过程被提升了，但是初始化没有提升。
2. var 的「创建」和「初始化」都被提升了。
3. function 的「创建」「初始化」和「赋值」都被提升了。












# 函数作用域面试解题技巧



## 常用陷阱

- **函数执行的时机**
- **变量提升**



## 逐步推演去理解:

第一步:`时机`

```javascript
var a = 1
function fun(){
    console.log(a)
}
xxxxxxxxxxxxxxxxxxxxx
xxxxxxxxxxxxxxxxxxxxx
fun()  

请问:根据以上代码你可以推断出打印出来的值是多少吗?
   分析:
		我们是无法得出结论的
		因为fun()在执行时,那个'时机'下,`全局作用域里面的a是多少?`
如果`xxxx...xxx` 为`a=2`
那么fun()在执行时,那个'时机'下,全局作用域中 `a = 2`,打印的结果也自然是 2


思考:
var a = 1
function fun(){
    console.log(a)
}
fun()
 
结果是多少'__?'   // 1
```



**以上代码让我们认识到了  `时机`的重要性!!!**




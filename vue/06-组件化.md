# 什么是组件化

![](C:\Users\lenovo\Documents\一“桶”前端\myNote\vue\assets\什么是组件.jpg)



# 注册组件

![](C:\Users\lenovo\Documents\一“桶”前端\myNote\vue\assets\注册组件.jpg)

![](C:\Users\lenovo\Documents\一“桶”前端\myNote\vue\assets\注册组件-2.jpg)

![](C:\Users\lenovo\Documents\一“桶”前端\myNote\vue\assets\注册组件-3.jpg)

# 全局组件和局部组件

重要观点:

​		Vue()**实例对象其实本质上也可以看作一个组件**!

				1. 有模板,通过el属性 实现 挂载
   				2. 组件内部 和 模板之间传值 直接 使用
             				1. 思考: 子组件想使用实例组件的data数据怎么使用?  难道直接用?
             				2. 很明显不行, 想到这一点 , 对后面搞清 父子组件传值 还是比较重要的



`Vue.extend ()+ Vue.componnet()` 实现的就是全局组件



## 局部组件

`componnets`:  组件选项

组件标签名: 组件构造器





# 父组件和子组件

- ==父组件在Vue实例 注册 , 子组件在父组件构造器里注册==

  - 父组件在使用的时候,内部已经编译好了

  - 编译到子组件时,会去父组件注册选项去找,找到就直接编译完成

  - 没找到, 就去Vue实例注册选项去找

    

- ==组件注册不会传递 , 换句话说 组件有自己的作用域==





# 注册组件的语法糖

![](C:\Users\lenovo\Documents\一“桶”前端\myNote\vue\assets\Vue语法糖.jpg)

注册全局组件

```javascript
原来注册全局组件:
 //	1. 创建组件构造器
const componentInstence = Vue.extend({
    template:`
		<div>
			<h2>我是组件</h2>
		</div>
`    
})
 // 2. 注册组件
 Vue.Component("cpnI1",componentInstence)

语法糖写法:
Vue.Component("cpnI1",{
    template:`
		<div>
			<h2>我是组件</h2>
		</div>
`    
})	

本质上内部还是会去调用 extend
```



注册局部组件

```javascript
原来注册局部组件
const componentInstence = Vue.extend({
    template:`
		<div>
			<h2>我是组件</h2>
		</div>
`    
})
const app = new Vue({
    el:'#el',
    data:{
        msg:""
    },
    component:{
        "cpnI1":componentInstence
    }
})
语法糖写法:
 const app = new Vue({
    el:'#el',
    data:{
        msg:""
    },
    component:{
        "cpnI1":{
   			 template:`
				<div>
					<h2>我是组件</h2>
				</div>
				`    
			}
    	}
}) 
```



## 组件模板抽离

方式一

1. `<script type="text/x-template" id="tem1"></script>`
2. 在标签内写html代码
3. 在template选项里面: `template:"#temp1"`

方式二

1. 使用`<template id="tem1">`标签包裹 模板
2. 在template选项里面: `template:"#temp1"`





# 父子组件的传值

**子组件是不可以直接获取父组件data里面的数据的!!**

![](C:\Users\lenovo\Documents\一“桶”前端\myNote\vue\assets\父子组件传值.jpg)

组件自己的数据存放在data选项中:

- 必须时一个函数
- `data(){return {msg:"hah"}}`



## 为什么组件data必须是一个函数?




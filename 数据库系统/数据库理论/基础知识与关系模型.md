# 数据库的地位

> 地位

定义: 数据的集合就是数据库

意义: 数据就是计算机的生命 , 计算机的存在就是为了储存数据 , 处理数据

​		 展示数据用的!!



> 课程相关联系

离散数学 --> 数据结构 -->数据库系统

编译原理+操作系统 辅助 数据库系统





# 初步认识数据库系统

## 概念区分

> 数据库

电子化信息的集合

将信息**规范化**、电子化 , 方便存储 , 检索 , 统计与管理



> table的规范化

1. 表的抽象

表头行 = 列名(1)+列名(2)+...

普通行 = 行/元组/记录

列 = 字段/列/属性

模式 = 表名 + 表头行

表内容 = 值…

表 = 关系

2. database定义

**相互之间有关联关系的table集合**

举例 : 学生记录表  和 学生成绩表  之间存在关系





> 数据库系统 DBS

- 相当于**工作环境**
  - DB
  - DBMS
  - DBA
- 集成的环境就是DBS



## 认识DBMS



> 用户角度看DBMS

1. 能定义DB 和 table
   1. 提供了一套接口 : 数据定义语言 「DDL:data  define language」
   2. 根据接口语法 建立 table + database

2. 数据库操作 –- 增删改查
   1. 接口: DML语言 (data manage language)
3. 数据库控制
   1. 接口 : DCL语言(data control language)
   2. 决定数据的访问权限
4. 数据库的维护
   1. 转储/恢复/重组/性能监测/分析



> 从系统角度看DBMS

1. ''形式-->构造–->自动化 " 

![](assets\数据库建表过程.jpg)



DDL: 负责将**表的形式**创建好

DML : 负责完成表的**构造**(也就是表的**建设**)

分别有两个编译器

​	DDL编译器

​	查询编译器



2. 完成对DB的管理
   1. DBMS 可以越过os完成对内存的操作
   2. DBMS的每种语言都有一个编译器 和 执行引擎 完成相应的功能

3. DBMS是一起列程序的集合
   1. 语言编译器
   2. 查询优化
   3. 数据存取和索引
   4. 通信控制
      1. 网络环境下数据库的操作和数据传输的手段
      2. jdbc 数据库链接技术
   5. 事务管理
   6. 各种控制程序





## DBMS的语言

- 数据定义语言「DDL」
  - 定义数据格式
- 数据操作语言「DML」
  - 对数据的完善补充
- 数据控制语言 「DCL」
  - 数据的权限管理
- 组成在一起称呼为SQL语言



> 详细理解

1. DDL

定义表名 , 表头 , 列名

2. DML

增删改查数据

3. DCL
   1. 定义对不同操作的约束
   2. 定义对不同用户的约束







# DBS的结构抽象和演变

## 如何抽象一个数据库系统

> 分层抽象

**三个层次:**

1. 用户可以看到的数据
   1. 数据库中全部数据的一个部分
2. 全局看到的数据, 含相应的关联约束
3. 存储在硬盘上的数据 : 存储路径 + 存储方式 + 索引方式



> 数据(视图)与模式

数据 : 一个记录

视图 : 记录的集合

模式 : 表名 + 表头



> 三级模式和两层映像 

1. 三级模式
   1. 用户看到的数据的**结构描述** , 表头
   2. 全局角度的数据的**结构描述** , 表头+约束
   3. 数据在介质上的**结构描述 ** , 表头+约束 + 索引

2. 两层映像
   1. 作为程序的开发者 , 需要扮演的角色往往是第二级  也就是完成表格的创建和约束
   2. 根据表格的创建和约束 , 可以对用户设计功能和权限 , 可以在一定程度上对数据的索引查询进行优化
   3. 从中间到两头的开发就是所谓的两层映像

> 为什么要分层抽象

1. 两个独立性
   1. 逻辑数据独立性
      1. 中间增改变时 ,  可以不改变用户层 , 从而不用再次开发应用程序
   2. 物理数据的独立性
      1. 当存储的介质或者环境改变时 , 可以不改中间层级
      2. 保证了数据的可维护性
2. 作用
   1. 数据可维护性提高
      1. 即使换个以硬盘备份数据 , 也是可以直接用于生产
   2. 数据的可扩展性提高
      1. 即使临时增加字段  ,  表也不会数据混乱
      2. 仅仅只需要对该字段进行补充开发就好 , 不用重新开发应用程序



## 数据模型

> 数据**模型**  「注意不是模式 : = 表名+表头」

数据结构 + 操作 + 约束 =  数据模型

比如

关系模型:

1. 模式 抽象 成 table
2. table 可以增删改查数据
3. table可以对数据添加约束

关系模型:

模型1:

学生登记表( 学号 char(8), 姓名char(10), 性别 Char(2), 出生年月datetime, 入学日期 Datetime, 家庭住址Char(40) )

模型2:

学生成绩单( 学号 char(8), 姓名char(10), 班级 Char(6), 课程 char(40), 学期 Char(4), 成绩 Number ) 



> 三大经典数据模型

- 关系模型 --表的形式组织数据
- 层次模型 --树的形式组织数据
  - mongonDB就是层次模型
  - redis呢
- 网状模型 --图的形式组织数据





## 关系模型

- 一个关系就是一个table
- 组成
  - 模式 = 表名 + 表头
  - table与table 之间可能的各种操作 「关系运算」
  - 操作所应该遵循的约束 「完整性约束」
- 掌握
  - table 如何定义和描述
  - table与table 之间的操作有哪些 ? 操作的结果是什么?
  - 有哪些约束?



> 关系模型三要素

1. 基本结构 : 模式
2. 基本操作 : 关系运算
   1. U : 并 ; —: 差 ;  X:广义积
   2. 选择 ; 投影
   3. 交集  ; 链接 ; 除
3. 完整性约束





## 关系

> 表的严格定义 -- 关系

1. 首先定义‘列'’的取值范围 "域"(Domain)
   1. 域: 一组指的集合
   2. 基数 : 集合中元素的个数
2. 再定义"元组" 以及可能出现的元组 : 笛卡尔积
   1. 笛卡尔积 : n个D, 每个D取一个d , 组成的元组就是笛卡尔积(d1,d2,…,dn)
   2. 分量 : (d1,d2,…,di,...dn) 元组中的di就是分量
3. 关系
   1. 笛卡尔积的子集 : 有意义的元组的集合
   2. 由于关系的不同列可能来自同一个域 , 为了区分 , 需要为每一列起一个名字 , 改名字为**属性名**
   3. 关系模式 : 举例 : 家庭(丈夫:男人,妻子:女人,子女:儿童) 格式 : name(属性名x: Dx,)
      1. 属性像域的映像一般直接说明为属性的类型
   4. 关系模式与关系
      1. 关系模式是表名+表头
      2. 关系是表
      3. 表名+表头 可能一样 , 但是表不一样



> 关系的特性

1. 列的同质: 同一列中的分量来自同一个域
2. 不同的列可以来自同一个域 : 称为属性
3. 列位置互换性 : 一个关系列位置互换还是看作同一个关系
   1. 区分关系 , 不是看关系列的位置 , 而是列的名字
   2. 区分原组, 也是同理 , 是看莫一列的列值
4. 属性不可再分
   1. 又称为关系的第一范式



> 关系上的重要概念

- 候选码/候选键
  - 可以 用来唯一标识一个元组的一列,或者列的集合
- 主码/主键
  - 当有多个候选码时 . 可选定一个作为主码
- 主属性/非主属性
  - 包含在任何一个候选码中的属性称为主属性
- 外码/外键
  - 关系1的一个属性组 , 不是1的候选码 , 而与关系2的候选码相对应 , 那么把这个属性组称为关系1的外键/外码
  - 两个关系通常是靠外键联系起来的



> 关系中的完整性

- 实体完整性
  - 关系主码中的值不能为空 (必须承担主码的作用)
- 参照完整性
  - 如果存在外键 , 那么把外键作为主键的那个关系必须存在
- 用户自定义完整性
  - 自定义D , 从而完成对列/属性的约束





## 关系代数

> 重点

1. 基于集合
2. 集合思维的操作语言
3. 学习其他数据库语言的基础



> 关系代数的操作

集合操作 : 交集 , 并集 , 差集 ,笛卡尔积

纯关系操作 : 选择: 关系的子集 ; 投影:关系的一些列组成的新的关系; 

- 连接 : 多表之间的操作
  - R与S的笛卡尔积中 , 选出R中属性A 和 S 中属性B 之间满足一些关系的元组构成的表
- 连接的常见扩展操作
  - R与S 的笛卡尔积
  - 从笛卡尔积选出符合条件的元组集合关系X
  - 对关系X , 进行列投影
- 关系自身的连接操作
  - 进行更名操作 , 形成形式上的新关系 「R 和R′」
  - 把R 和R′ 进行笛卡尔积 运算
  - 筛选出 , 符合条件的元组
  - **关键:** 自身更名形成另一个表
- 等值连接
  - R与S的笛卡尔积中 , 选出**R中属性A 和 S 中属性B 关系相等**元组构成的表
- 自然连接
  - 是一种特殊的等值连接
  - R与S有相同的属性X, 按照属性X相等形成
  - 步骤:
    - 两个表进行广义笛卡尔积
    - 选取在相同列上值相等的元组
    - 去掉重复列
    - 投影



## 关系代数复杂操作

> 除操作

步骤:

1. R中的属性 - S中的属性
2. 元组规则 : R÷S 的元组 + S中的元组  组合成 R的元组
3. 保证进行S 和 R÷S  笛卡尔积 , 元组在R中依旧可以找到



> 外连接

核心: 多表连接的失配问题的解决

1. 外连接 = 自然连接 + 自然连接失配的元组(用空值补充)
2. 外连接形式
   1. 左外连接:左侧表失配
   2. 右外连接: 右侧表失配
   3. 全外连接 : 两侧表都失配
3. 应用: 可以保证主表的完整信息不丢失的情况下 , 得到信息的补充





## 关系元组演算

> 要点:

- SQL 语句 , 是基于关系代数 + 关系元组演算 , 提炼而成的



> 关系元组演算的基本公式

1. t ∈ R   // t是关系R中的一个元组
2. t[x] θ y  // t元组中的一个属性分量值 与 y 之间的关系 : 大于? 小于? 等于?
3. t[x] θ s[y]  

 

> 基本公式配合与或非

1. 与 and  ∧
2. 或  or  ∨
3. 非  not  ∟



> 基本公式与全称量词和存在量词

1. 存在   有一个
2. 任意   所有



> QUE 语言




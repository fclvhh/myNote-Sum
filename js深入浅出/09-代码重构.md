

# 代码优化基本原则

1. 易读性优先
2. 如果不是性能瓶颈，就不要为了性能而改写代码
3. 复杂性守恒原则 , 无论你怎么写代码，复杂性都是不会消失的

> 推论：

如果逻辑很复杂，那么代码看起来就应该是复杂的。如果逻辑很简单，代码看起来就应该是简单的。





# 命名

程序员三大难

1. 变量命名
2. 缓存失效
3. 循环边界



可见变量命名的重要性。

网上有很多命名规范 大家可以参考。本节课只讲基本原则。



1. 注意词性

> 普通变量/属性用「名词」

```js
var person = {
    name:'fcdada'
}
var student = {
    grade:3,
    class:2
}
```



> bool变量/属性用「形容词」或者「be动词」或者「情态动词」或者「hasx」

```js
var person = {
    dead:false,      //形容词直接写
    canSpeak:true,   // can+动词
    isVip : true,   //be动词+名词
    hasChildren:true   //has+名词
}
```



> 普通函数/方法 用「动词」开头

```js
var person = {
    run() {},
    drinkWater() {},
    eat(foo) {}
}
```



> 回调、钩子函数用「介词」开头  或 用「动词的现在完成时」

```js
var person = {
    beforeDie(){},
    afterDie(){},
    willDie() {}
    dead() {}
}
```



> 容易混淆的地方加前缀

```js
如 : $xx -->代表jQuery 对象
```



2. 注意一致性

>
> 介词一致性

如果你使用了before+after , 那么就在代码的所有地方都坚持使用
如果你使用了before+完成时，那么就坚持使用
如果你改来改去，就「不一致」, 不一致将导致「不可预测」



> 顺序一致性

比如updateContainerWidth和updateHeight0fContainer的顺序就令人很奇怪，同样会引发「不可预测」



> 表里一致性

函数名完美体到函数的功能,既不能多也不能少。
比如

```js
function getSongs() {
    return $.get('/songs').then((response)){
        div.innerText = response.songs
    }
}
```



就违背了表里一致原则，getSongs表示获取歌曲 ，并没有暗示这个函数会更新页面

但是实际上函数更新了页面，这就是表里不一

> 正确的写法是

要么纠正函名
`functiongetSongsAndUpdateDiv(){}`
要么写成两个函数



> 时间一致性



有可能着代码迁移，一个变量的含义已经不同于它一开始的含义了，这个时候你需要及时改掉这个变量的名字。
这一条是最难做到的，因为写代码容易，改代码难。如果这个代码组织的不好，很可能会出现牵一发而动全身的情况（如全局变量就很难改〕







# 改代码

如果代码具有单元测试 , 那么改起来就很放心 . 如果没有单元测试 , 就需要用「小步快跑」的策略来修改. 

小步快跑的意思就是 , 每次只修改一点点 , 测试通过后 , 再修改一点点 …. 如此反复

基本只有两个方法:

1. 使用函数
2. 使用对象

## 使用函数来改代码

> 步骤:

1. 将一坨代码放到一个函数里面
2. 将代码依赖的外部变量作为参数
3. 将代码输出作为函数的返回值
4. 给函数取一个合适的名字
5. 调用这个函数并传入参数
6. 这个函数的代码如果超过5行 , 则依然有优化的空间
   1. 也就是继续查分成小函数
   2. 代码里会有无数个小函数





## 使用对象来改代码

如果使用了函数改造法之后 , 发现有太多的小函数 , 则可以使用对象将这个函数

串联起来

「this是函数和对象的桥梁」, 用this来串联这个对象和所有的函数





## 一些固定的套路

1. 表驱动编程

> 所有一一对应的关系都可以用表来做

2. 自说明代码(以API为例)

> 把别人关心的东西放在显眼的位置





# bad smell(知道自己写的是坏代码)

如下情景:

1. 重复的代码

抽离出来 , 写一个函数 , 让别人调用

2. 相似的代码

抽来出函数 , 传入不同的参数 , 来区分功能的不同

3. 总是一起出现的代码

逻辑紧密相连  ,  **你变我也必须变**

封装成一个函数 , 来操作 , 就可以减少bug




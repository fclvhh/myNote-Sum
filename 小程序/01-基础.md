

















# 小程序渲染页面

## 宿主环境

![](assets\miniProgram-5.jpg)



**宿主环境 : 微信客户端**

​	微信客户端 , 负责执行wxml文件 wxss文件 js文件

​	为了达到目的 , 有了双线程机制



## **双线程模型:**

webview + jsCore

webview: 渲染层模型 , 负责执 行   wxml+wxss



webview具体功能: 

1. 解析wxml和wxss   =>  虚拟DOM树   =>也就是用js对象模拟的DOM的树结构  

> 树结构 , 可以很很好的被对象表达
>
> 这是很重要的思维提升!!!
>
> 为什么语言的对象如此重要 , 也许就源于树结构的普遍重要!

![](assets\miniProgram-6.jpg)



2. 将js对象 , 渲染成真实DOM



3.  将文档生成js对象 「虚拟DOM」, 将js对象生成真实DOM 「渲染」



## 思考:

 ==webview这个线程把活干的好好的!!! 为什么要引入第二个线程 jsCore呢?==



需要给页面的数据注入流动性!!!

看一个例子

```html
<view>我的年龄:18</view>
```

过了一年 , 年龄变19 , 怎么办?

cope 一个页面 , 然后修改这个数据 , 然后再重新部署到服务器?!  

拜托 , 就修改一个数据罢了!!! 这么麻烦!



现在开发

```html
<view>我的年龄:{{age}}</view>
```

这个页面的数据是活的 , 是要获取的!!!

![](assets\miniProgram-3.jpg)



## 第二个核心的功能:

1. 帮助webview获取数据  生成js对象
2. 当数据发生变化了 ,  通知webview 和 webview 生成第二个js对象



两个js对象 , 通过diff 算法 , 比较出差异 

只会把差异部分渲染到页面上 , 不会重新渲染整个js对象

![](assets\miniProgram-4.jpg)

























# 小程序数据流动

1. 占位: 绑定
2. 数据展示 : for
3. 数据修改    思路: 事件机制



axios拿到数据模型 , 放到 data里面暂存



回调拿到res

分析数据的结构 , 定义变量  分类存储

this.变量名  =>拿到细分数据   

根据这个就可以修改数据



要在setData( ) 修改数据

​	





# 小程序启动流程

## 第一小结

1. 流程图
2. App()

```js 
App({
    onlauch:()=>{
        
    },
})
```

onlauch 生命周期函数 初始化小程序 ,并给至少存活2小时  

​              换句话说:两个小时之内只会执行一次

onhide : 切到后台

onshow: 小程序显示时 , 会执行多次



## 注册App经常做的

1. 判断小程序的**进入场景**

进入场景:

​     打开小程序的方式, 如:点开链接打开 , 扫码打开 , 下拉微信打开 , 微信发现打开

2. 在生命周期执行业务代码